%% This code and its associated data can be used subject to citing the following research works:

% [Ref1] A.M. Sabatini, "Quaternion-Based Extended Kalman Filter for
% Determining Orientation by Inertial and Magnetic Sensing"
% IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 53, NO. 7, JULY 2006.

% [Ref 2] A.M. Sabatini, "Estimating Three-Dimensional Orientation of Human 
%  Body Parts by Inertial/Magnetic Sensing"
%  Sensors 2011, 11, 1489-1525; doi:10.3390/s110201489

% [Ref 3] M. Caruso et al., “Accuracy of the Orientation Estimate Obtained 
% Using Four Sensor Fusion Filters Applied to Recordings of Magneto-Inertial
% Sensors Moving at Three Rotation Rates,” 
% in 2019 41st Annual International Conference of the IEEE Engineering in Medicine and Biology Society (EMBC), 2019.

% [Ref4] M. Nazarahari, H. Rouhani, "Sensor Fusion Algorithms for Orientation
% Tracking via Magnetic and Inertial Measurement Units: An Experimental 
% Comparison Survey", 2021 (Under Review).

% [Ref5] M. Nazarahari, H. Rouhani, "Adaptive Gain Regulation of Sensor Fusion
% Algorithms for Orientation Estimation with Magnetic and Inertial
% Measurement Units", IEEE Transactions on Instrumentation and Measurement,
% VOL. 70, 2020.

% [Ref6] Marco Caruso et al., "Orientation Estimation Through 
% Magneto-Inertial Sensor Fusion: A Heuristic Approach for Suboptimal 
% Parameters Tuningy", IEEE Sensors Journal (Volume: 21, Issue: 3, Feb.1, 1 2021).

%============================================================================
% Copyright (C) 2019, Milad Nazarahari, University of Alberta, December 2020
% 
% Permission is hereby granted, free of charge, to any person obtaining a
% copy of this software and associated documentation files (the "Software"),
% to use the software as is "ONLY" for non-commercial purposes. Also, 
% modification, merging, publishing, and distributing the Software or part of it
% are permitted provided that the following conditions are met:

% (1) Each user MUST check the original license of the Software generated by its
% original author(s) and comply with all the limitations/restrictions of
% the original license.

% (2) The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.

% (3) For all non-commercial purposes: this Software and its associated data
% can be used subject to obtaining written permission for contributors
% or the citing the research works mentiond above.

% (4) For commercial purposes:  Contact Milad Nazarahari (nazaraha@ualberta.ca) 
% or Dr. Hossein Rouhani (hrouhani@ualberta.ca).

% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
% DEALINGS IN THE SOFTWARE.
%============================================================================

%% Sensor Fusion Algorithm
function [State] = Sabatini2006_HS(data, IMU_Fs, Param, QS)
% This function implements  the sensor fusion algorithm proposed in
% "Quaternion-Based Extended Kalman Filter for Determining Orientation by Inertial and Magnetic Sensing"
% by Angelo M. Sabatini, IEEE TRANSACTIONS ON BIOMEDICAL ENGINEERING, VOL. 53, NO. 7, JULY 2006
% &
% Estimating Three-Dimensional Orientation of Human Body Parts by Inertial/Magnetic Sensing
% by Angelo Maria Sabatini, Sensors 2011, 11, 1489-1525; doi:10.3390/s110201489

%%% This code originally implemented by
% Marco Caruso (Politecnico di Torino), marco.caruso@studenti.polito.it
% Date: 21/11/2019

% The ORIGINAL code was modified by Milad Nazarahari
% (nazaraha@ualberta.ca), during Ph.D. studies under supervision of Dr. H. Rouhani
% (hrouhani@ualberta.ca), University of Alberta, December 2020 as a part of
% a comparative/benchmarking sutdy.

% The MATLAB code performs the operations of the ORIGINAL code except for:
% reference acceleration/magnetic field (Earth's magnetic field)
% was obtained from sensor readout during motionless perioed at the begining of the experiment
% & implementing adaptive parameter tuning (hard-switch) & accelerometer and
% magnetometer bias were added as states

%  --------------- INPUT ---------------
%%%% "data" including
% acc            = Nx3 (m/s^2)
% gyr            = Nx3 (rad/s)
% mag            = Nx3 (a.u.) normalized units
% Fs             = sampling frequency of the IMU (Hz)
% QS             = 1x2 (s) motionless period at the begining of the trial

%%%% Params
% (1,1) P_initial      = 1x1 initial error covariance matrix
% (1,2) SIGMA_g        = gyrsocope noise for process noise covariance matrix static
% (1,3) SIGMA_g        = gyrsocope noise for process noise covariance matrix dynamic
% (1,4) epsilon_g      = threshold for switching between (1,2) & (1,3)
% (1,5) stdBiasAcc_in  = 1x1 (m/s^2) initial value for Accelerometer bias covariance matrix
% (1,6) stdBiasMag_in  = 1x1 (a.u.) initial value for magnetometer bias covariance matrix
% (1,7) stdAcc         = accelerometer noise for measurement noise covariance matrix static
% (1,8) stdAcc         = accelerometer noise for measurement noise covariance matrix dynamic
% (1,9) epsilon_a      = threshold for switching between (1,7) & (1,8)
% (1,10) stdMag        = magnetometer noise for measurement noise covariance matrix static
% (1,11) stdMag        = magnetometer noise for measurement noise covariance matrix dynamic
% (1,12) epsilon_m     = threshold for switching between (1,10) & (1,11)

% --------------- OUTPUT ---------------
% qsab                 = Nx4 [qx qy qz qw], the scalar part is at the END of the quaternion


accel = data(:, 1:3);
gyro = data(:, 4:6);
mag = data(:, 7:9);

len = size(accel,1);
State = zeros(len, 4);

dt = 1/IMU_Fs;

quaternion = [0 0 0 1 0 0 0 0 0 0]';

P = Param(1)*eye(10); % initial error covariance matrix

% PROCESS NOISE
SIGMA_a = dt*Param(5)^2*eye(3);
SIGMA_m = dt*Param(6)^2*eye(3);

% Constants
g = norm(mean(accel(QS(1)*IMU_Fs:QS(2)*IMU_Fs, :))); % gravitational acceleration
h = mean(mag(QS(1)*IMU_Fs:QS(2)*IMU_Fs, :)); % Earth's magnetic field (global Frame)

for i = 1:len
    % Updating Gyro noise adaptively (Q)
    if norm(gyro(i,:)) <= Param(4)
        SIGMA_g = Param(2)^2*eye(3);
    else
        SIGMA_g = Param(3)^2*eye(3);
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%% PREDICTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    wx = gyro(i,1); wy = gyro(i,2); wz = gyro(i,3);
    omega = 0.5*[0    wz -wy wx
        -wz    0     wx wy
        wy -wx    0    wz
        -wx -wy -wz  0];%skew symmetric
    
    Phi = [expm(omega*dt) zeros(4,6)
        zeros(3,4) eye(3) zeros(3,3)
        zeros(3,7) eye(3)];
    
    % Project the state ahead
    quaternion_ = Phi*quaternion;
    
    CSI = [[0 -quaternion(3) quaternion(2);
        quaternion(3) 0 -quaternion(1)
        -quaternion(2) quaternion(1) 0]+quaternion(4)*eye(3);...
        -quaternion(1:3)'];
    
    Q = [(dt/2)^2*CSI*SIGMA_g*CSI' zeros(4,6)
        zeros(3,4) SIGMA_a, zeros(3,3)
        zeros(3,7) SIGMA_m];
    
    % Compute the a priori covariance matrix
    P_= Phi*P*Phi'+Q;
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%% UPDATE STEP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    q1 = quaternion_(1); q2 = quaternion_(2); q3 = quaternion_(3); q4 = quaternion_(4);
    
    % Linearize the measurement equation: Jacobian
    F = [[2*g*[q3 -q4 q1 -q2
        q4 q3 q2 q1
        -q1 -q2 q3 q4];
        2*[q1*h(1)+q2*h(2)+q3*h(3), -q2*h(1)+q1*h(2)-q4*h(3),   -q3*h(1)+q4*h(2)+q1*h(3), q4*h(1)+q3*h(2)-q2*h(3)
        q2*h(1)-q1*h(2)+q4*h(3),     q1*h(1)+q2*h(2)+q3*h(3), -q4*h(1)-q3*h(2)+q2*h(3), -q3*h(1)+q4*h(2)+q1*h(3)
        q3*h(1)-q4*h(2)-q1*h(3),       q4*h(1)+q3*h(2)-q2*h(3),     q1*h(1)+q2*h(2)+q3*h(3), q2*h(1)-q1*h(2)+q4*h(3)]
        ] [eye(3) zeros(3,3); zeros(3,3) eye(3)]];
    
    % Adapt the measurement covariance matrix
    C = [q1^2-q2^2-q3^2+q4^2 2*(q1*q2+q3*q4) 2*(q1*q3-q2*q4)
        2*(q1*q2-q3*q4) -q1^2+q2^2-q3^2+q4^2 2*(q2*q3+q1*q4)
        2*(q1*q3+q2*q4) 2*(q2*q3-q1*q4) -q1^2-q2^2+q3^2+q4^2];
    
    % Accelerometer
    if norm(accel(i,:) - C*[0;0;g] - quaternion_(5:7)) < Param(9) % (Eq 70 in 2011 paper)
        std_acc = Param(7);
    else
        std_acc = Param(8);
    end
    
    % Magnetometer
    if norm(mag(i,:) - quaternion_(8:end) - h) < Param(12) % (Eq 71 in 2011 paper)
        std_mag = Param(10);
    else
        std_mag = Param(11);
    end
    
    % Measurement covariance
    R = [std_acc^2*eye(3) zeros(3,3)
        zeros(3,3) std_mag^2*eye(3)];
    
    % Compute the Kalman Gain
    K = P_* F' * (F * P_ * F' + R)^-1;
    
    % Compute the a posteriori state estimate
    z = [accel(i,:)'; mag(i,:)']; % measurement vector
    z_predict = [C zeros(3,3); zeros(3,3) C]*[0; 0; g; h'] + quaternion_(5:end);
    quaternion = quaternion_ + K*(z - z_predict);
    
    % Normalize the quaternion
    quaternion(1:4) = quaternion(1:4)/norm(quaternion(1:4));
    
    % Compute the a posteriori covariance matrix
    P = P_ - K*F*P_;
    
    State(i,:) = quaternion(1:4);
    
end

end
